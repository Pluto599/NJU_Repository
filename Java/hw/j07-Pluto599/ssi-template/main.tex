\documentclass{SCIS2026cn}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 作者附加的定义
%%% 常用环境已经加载好, 不需要重复加载
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 开始
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 作者不需要修改此处信息
\ArticleType{论文}
%\SpecialTopic{}
\Year{2026}
\Vol{}
\No{}
\BeginPage{1}
\DOI{}
\ReceiveDate{}
\ReviseDate{}
\AcceptDate{}
\OnlineDate{}
%\online %online命令在BeginPage之后
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Developing a Java Game from Scratch}

\entitle{Developing a Java Game from Scratch}{Developing a Java Game from Scratch}

\author[1]{刘佳璇}{Jiaxuan LIU}{{13573529579@163.com}}
\AuthorMark{刘佳璇}
\AuthorCitation{刘佳璇}
\enAuthorCitation{Liu J}

\address[1]{南京大学 计算机科学与技术系}{Department of Computer Science and Technology, Nanjing University}

\Foundation{}

\maketitle

\section{引言}

在传统的 Java 教学中，语言特性、库使用与面向对象思想往往被割裂开来讲解，学生较少有机会在一个长期、复杂且具有明确工程目标的项目中，系统性地运用这些知识。《高级 Java 程序设计》课程通过分阶段布置游戏开发作业，引导学生从零开始构建一个可演进的软件系统，为理解 Java 在实际工程中的能力边界提供了良好的实践环境。

本文所描述的项目正是在该课程框架下完成的一个综合性游戏开发实践。与仅关注玩法或图形效果的游戏 Demo 不同，该项目的核心目标并非“做出一个好玩的游戏”，而是通过游戏这一高度综合的应用场景，系统性地实践面向对象设计、并发编程、网络通信、渲染抽象以及软件工程方法。

\section{开发目标与游戏设计构想}

\subsection{总体目标}

本项目的最终目标是开发一个完整的 Java 网络游戏系统，其应满足以下条件：

\begin{itemize}
  \item 具备清晰的引擎与游戏逻辑分层；
  \item 支持实时输入、更新与渲染循环；
  \item 能够在单机模式与网络联机模式下运行；
  \item 支持游戏过程的录制、回放与存档加载；
  \item 具备可维护、可扩展、可测试的工程结构。
\end{itemize}

因此，本项目的成果不仅是一个可运行的游戏程序，更是一个具备基本通用性的轻量级游戏引擎。

\subsection{游戏形态与灵感来源}

在具体游戏形态上，项目选择了结构相对简单但技术要素齐全的实时射击类游戏。玩家通过键盘输入控制角色移动，与环境或敌对对象进行交互。该选择并非追求复杂的玩法设计，而是为了将开发重心放在引擎结构、系统协作以及性能与稳定性问题上。

这一设计思路的灵感主要来源于经典的 2D 射击与避障类游戏。这类游戏对实时性要求较高，同时又不依赖复杂的资源系统，非常适合作为课程项目的载体。

\section{总体架构设计与设计理念}

\subsection{总体结构}

项目整体采用了高度模块化的设计。核心模块包括：

\begin{itemize}
  \item core：游戏循环、引擎主流程；
  \item scene：场景生命周期与切换管理；
  \item objects / components：基于 ECS 的实体与组件；
  \item graphics：渲染抽象与具体实现；
  \item input：输入系统；
  \item net：网络通信与同步；
  \item recording / replay / save：录制、回放与存档系统。
\end{itemize}

各模块之间通过接口或抽象类进行交互，避免了不必要的直接依赖。

\subsection{ECS 架构的引入}

项目核心采用 Entity--Component--System（ECS）架构，将传统面向对象中“继承层级复杂、职责混杂”的问题拆分为：

\begin{itemize}
  \item Entity：仅作为唯一标识的容器；
  \item Component：纯数据或单一行为描述；
  \item System：面向过程的批量处理逻辑。
\end{itemize}

这种设计显著降低了类之间的耦合度，使得新功能的加入通常只意味着新增组件或系统，而无需修改已有类结构。

\section{关键技术问题与解决方案}

\subsection{游戏循环与更新节奏控制}

游戏引擎采用固定更新频率与渲染解耦的主循环模型。逻辑更新以固定时间步推进，而渲染则尽可能快地执行。这种方式既保证了物理与逻辑的一致性，又避免了因帧率波动导致的行为异常。

\subsection{并行计算与性能优化}

在 j04 阶段，项目对物理更新与碰撞检测进行了系统性的性能分析。物理更新属于天然可并行的问题，而碰撞检测则通过对象筛选与任务分块的方式降低了计算复杂度。

并行化通过 Java 的 \texttt{ExecutorService} 实现，避免了显式线程管理带来的复杂性。实践表明，在对象数量较多的情况下，并行方案显著降低了单帧计算时间。

\subsection{GPU 渲染与抽象设计}

在后续版本中，项目由 Swing 渲染迁移至基于 LWJGL 的 OpenGL 渲染。通过定义统一的渲染接口，上层逻辑无需感知具体渲染后端，从而保证了代码的可演进性。

文本渲染采用 AWT 字体离屏生成纹理再交由 GPU 批量绘制的方式，在性能与实现复杂度之间取得了良好平衡。

\subsection{网络通信与客户端插值}

网络联机部分采用 Java NIO 构建服务器端，使用单线程 Selector 处理多连接事件，避免了传统阻塞式模型在高并发下的资源消耗问题。

服务器采用权威模式定期广播关键帧，客户端通过时间戳缓存并进行线性插值，从而在存在网络抖动的情况下仍能保持平滑的视觉效果。

\subsection{录制、回放与存档系统}

录制系统以 JSONL 形式记录输入事件与关键帧状态。回放时，通过插值重建中间状态，实现了与实时游戏几乎一致的视觉效果。单机模式下，存档系统则复用相同的数据结构，实现了代码复用与功能统一。

\section{工程方法与软件工程实践}

\subsection{Maven 与依赖管理}

项目最终全面迁移至 Maven 构建体系，统一管理第三方库依赖、编译流程与测试执行。这一改动显著提升了项目的可移植性与可复现性。

\subsection{持续集成与自动化测试}

通过 GitHub Actions，项目在每次提交时自动执行构建与测试流程。JUnit 单元测试覆盖了核心模块，有效防止了回归错误。

\subsection{可测试性设计}

在设计过程中，核心逻辑尽量避免与渲染或 I/O 直接耦合，使得大部分功能可以在无窗口环境下进行测试。这一实践显著降低了测试成本。

\section{课程感言与建议}

通过本课程的学习，我深刻体会到长期工程项目在编程教学中的重要价值。相较于零散的小实验，持续演进的项目更能暴露设计问题，也更能促使学生主动思考架构与工程方法。

建议课程在未来进一步加深对设计代码框架的解读。

\end{document}
