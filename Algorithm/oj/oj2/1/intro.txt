题目：可能是原题

描述：
描述
助教看到这样一道题：给定一个长度为n的数组，保证[0,n−1]的每个整数都恰好出现一次，要求将该数组从小到大排序，数据范围是0≤n≤5000，不许使用STL。助教立刻开始写冒泡排序，然后突发奇想：该如何求出在冒泡排序过程中一共进行了多少次交换？以及每个数总共被交换了多少次？

于是助教写了一下代码计算这两个问题：

void bubble_sort(int a[],int n,int cnt[]){
    long long sum=0;
    for(int i=0;i<n;++i)cnt[i]=0;
    for(int i=0;i<n;++i){
        for(int j=0;j<n-i-1;++j){
            if(a[j]>a[j+1]){
                swap(a[j],a[j+1]);
                sum+=1;
                cnt[a[j]]+=1;
                cnt[a[j+1]]+=1;
            }
        }
    }
}
显然这只是一个普通的冒泡排序。sum代表交换的总次数，而cnt[i]代表整数i被交换的次数（注意，是等于i的数被交换的次数，而非初始位置为i的数被交换的次数）。

但助教还想知道当n更大时的答案，请问你可以写出效率更高的代码吗？

助教并不想难为你，你每次只需要回答两个问题的其中之一（前10个点只需求sum！）。

如果需要，你可以使用STL。

输入
多组数据。

第一行一个正整数T，代表数据组数。

对于每组数据的第一行，两个正整数n,op ，代表数组长度和你需要回答的问题，op=0代表求sum，op=1代表求cnt[]数组。

每组数据的第二行是n个整数，代表待排序的数组，保证是[0,n−1]的排列，即每个数恰好出现1次。

输出
共输出T行。

若第i组数据op=0，则输出一个数sum；否则输出一行整数，为该组数据的cnt[]数组。

样例
输入

2

4 0
0 2 1 3

3 1
2 0 1

输出

1
1 1 2 

样例解释

第一组数据，在冒泡排序的第一层循环i=1 时交换1和2，后面的循环里没有交换，共交换一次。

第二组数据，从前到后发生的交换为swap(2,1);，其中0被交换1次，1被交换1次，2被交换2次。

数据范围

对于所有点，满足 ∑n≤2×10^5
对于前10个点，满足op=0

提示
注意开long long, long long对应的scanf printf格式串为%lld

题中给出的代码效率不高，但是是正确的（前提是你为其加上了多组数据的处理）。如果debug不出来，可以自己造合法的数据（可以写一个c++程序生成），比较自己的代码和题面中代码的输出。

下面是使用c++程序生成数据可能需要的一些函数（也可用于其他题的调试），详细用法请大家自行上网查找。

srand(time(0));//放在主函数第一句，使得每次运行生成器程序生成的数据不一样
rand();//生成一个伪随机数
random_shuffle();//伪随机打乱一个数组
例如，如果你想生成数据组数为3，n在3到5之间，op=0的合法数据，你可以利用这三个函数使用如下代码生成：

#include <bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int rand_int(int l,int r){//生成[l,r]的随机整数，想一想其原理
    return rand()%(r-l+1)+l;
}
void gen(int minN,int maxN,bool op){//生成一组n属于[minN,maxN]，op=op的数据
    int n=rand_int(minN,maxN);
    printf("%d %d\n",n,op);
    static int a[N];
    for(int i=0;i<n;++i){
        a[i]=i;
    }
    random_shuffle(a,a+n);
    for(int i=0;i<n;++i){
        printf("%d ",a[i]);
    }
    printf("\n");
}
int main(){
    srand(time(0));//加在main函数第一句，使得在不同时间运行程序，生成的数据不一样。
    printf("3\n");
    for(int i=0;i<3;++i){
        gen(3,5,0);
    }
    return 0;
}
什么样的程序不会TLE呢？
不算太差的电脑，1秒可以进行超过10^8 次乘加运算。

助教写了这样一段代码：

#include <bits/stdc++.h>
using namespace std;
int main(){
    long long ans=1;
    for(int i=0;i<5e8;++i){
        ans=ans*19260817124321ll+1232233212332ll;
    }
    printf("%lld\n",ans);
    return 0;
}
邪恶的助教在自己的ubuntu22.04，i7-10510U的电脑上使用g++编译该代码，不加额外的编译参数，运行时间为0.94s。(不到1秒，已经5×10 
8
 次long long 乘加运算了)

考虑到课内学到的算法的常数都不会很大也不会很小，假如你的算法的时间复杂度是Θ(n 
2
 )，数据范围是n≤5000，那么5000×5000=2.5×10 
7
  ，远小于10 
8
 ，不会TLE。

但这道题的数据范围是∑n≤2×10 
5
 ，在极限情况下只有1组n=2×10 
5
 的数据（可以算出在这种情况下∑n 
2
 最大 ），2×10 
5
 ×2×10 
5
 =4×10 
10
 ，即使算上冒泡排序的1/2常数，也会TLE。由于这是算法课，不是计算机原理课或者编译原理等等，所以之后我们也不鼓励使用奇技淫巧利用Θ(n 
2
 )来通过类似如此数据规模的题。

特别注意：本OJ平台由于启动服务器等动作需要花费1s多的时间，所以一般我们每道题的时限给到3000ms。
请注意输出一行多个数字时末尾需要一个空格